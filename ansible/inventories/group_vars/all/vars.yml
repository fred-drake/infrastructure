---
# Force to use this specific interpretor
ansible_python_interpreter: /usr/bin/python3

cert_manager:
  cluster_issuer: letsencrypt-production

metallb:
  range: 192.168.50.225-192.168.50.250

traefik:
  address: "192.168.50.240"

# Domain name for your network (e.g. internal.mydomain.com)
domain_name: "{{ vault_domain_name }}"

kubegres:
    version: 1.9

notea_db:
  name: notea-db
  host: notea-db
  ui_host: notea-db-ui
notea:
  password: notea

# Hosts that are stored in the inventory
#
# Example:
# hosts:
#   foo:
#     hostname: foo.mydomain.com
#     user: joe
hosts: "{{ vault_hosts }}"

# The timezone used on servers and docker containers
default_timezone: America/New_York

# Information for our networks
#
# Example:
# network:
#  lan:
#    gateway: "192.168.1.1"
#    cidr: "192.168.1.0/24"
#  iot:
#    gateway: "192.168.10.1"
#    cidr: "192.168.10.0/24"
network: "{{ vault_network }}"

# Netbox parameters for API calls
netbox_token: "{{ vault_netbox_token }}"
netbox_api_prefix: "{{ vault_netbox_api_prefix }}"

# A list of machines used to configure the several Pihole instances.  In my particular case, I have two Pihole
# docker containers for each subnet.  The network attribute is the name of the docker network name, and subnet_id
# is the label that matches what you identified in the subnets_by_label dict above.
#
# Example:
# pihole_machines:
#   - hostname: pihole1-lan
#     address: "192.168.1.5"
#     network: "br0.1"
#     subnet_id: lan
#   - hostname: pihole1-iot
#     address: "192.168.10.5"
#     network: "br0.10"
#     subnet_id: iot
pihole_machines: "{{ vault_pihole_machines }}"

# A dict of subnet information needed by the DHCP server, grouped by label.
#
# Example:
# dhcp_nets:
#   lan:
#     subnet: "192.168.1.0"
#     netmask: "255.255.255.0"
#     router: "192.168.1.1"
#     dns1: "192.168.1.5"
#     dns2: "192.168.1.6"
#     range_start: "192.168.1.100"
#     range_end: "192.168.1.254"
#   iot:
#     subnet: "192.168.10.0"
#     netmask: "255.255.255.0"
#     router: "192.168.10.1"
#     dns1: "192.168.10.5"
#     dns2: "192.168.10.6"
#     range_start: "192.168.10.150"
#     range_end: "192.168.10.254"
dhcp_nets: "{{ vault_dhcp_nets }}"

# The list of machines that define the DHCP servers.  I run two docker containers for every
# subnet (a primary and secondary).  The fields are used to build the containers and configure
# DHCP at the machine level.
#
# Example:
# dhcp_machines:
#  - hostname: dhcp1-lan
#    address: "192.168.1.7"
#    network: br0.1
#    subnet_id: lan
#    type: primary
#    peer_address: "192.168.1.8"
#  - hostname: dhcp2-lan
#    address: "192.168.1.8"
#    network: br0.1
#    subnet_id: lan
#    type: secondary
#    peer_address: "192.168.1.7"
#  - hostname: dhcp1-iot
#    address: "192.168.10.7"
#    network: br0.10
#    subnet_id: iot
#    type: primary
#    peer_address: "192.168.10.8"
#  - hostname: dhcp2-iot
#    address: "192.168.10.8"
#    network: br0.10
#    subnet_id: iot
#    type: secondary
#    peer_address: "192.168.10.7"
dhcp_machines: "{{ vault_dhcp_machines }}"

# Information for all services, including IP address and other potential sercrets
#
# Example:
# services:
#  calibre:
#    ip: 192.168.1.20
#    api_token: super-secret-token
services: "{{ vault_services }}"

k8s:
  k3s_version: v1.21.5+k3s1
  flux_fingerprint: BF521FA92D478E4759FC81FA5C8A60849BE61D56
